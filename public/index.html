<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Web Watcher → Telegram</title>
<style>
  :root{
    --bg:#0f1221; --card:#161a31; --text:#eef1ff; --muted:#a4acc4;
    --accent:#7c5cff; --ok:#40d37a; --danger:#ff5470; --br:12px;
    --bd:1px solid rgba(255,255,255,.12)
  }
  *{box-sizing:border-box}
  body{
    margin:0; font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Arial;
    color:var(--text);
    background:
      radial-gradient(900px 500px at 12% -10%, rgba(124,92,255,.22), transparent),
      radial-gradient(700px 500px at 110% 0%, rgba(64,211,122,.18), transparent),
      var(--bg);
    min-height:100vh; display:grid; place-items:start center; padding:24px;
  }
  .wrap{width:100%; max-width:900px; display:grid; gap:16px}
  .card{background:linear-gradient(180deg,rgba(255,255,255,.05),rgba(255,255,255,.02));
        border:var(--bd); border-radius:var(--br); padding:16px}
  h1,h2,h3{margin:0 0 10px}
  .muted{color:var(--muted)} .small{font-size:.92rem}
  label{display:block; font-weight:600; margin:10px 0 6px}
  input,button,textarea{font:inherit; color:var(--text)}
  input,textarea,select{
    width:100%; background:#121530; border:var(--bd); border-radius:10px; padding:10px 12px; outline:none;
  }
  textarea{min-height:100px; resize:vertical}
  .row{display:flex; gap:10px; align-items:center; flex-wrap:wrap}
  .right{margin-left:auto}
  button{background:var(--accent); border:0; padding:10px 14px; border-radius:10px; cursor:pointer}
  .ghost{background:transparent; border:var(--bd)}
  .ok{background:var(--ok); color:#04160d}
  .danger{background:var(--danger)}
  .pill{padding:6px 10px; border-radius:999px; border:var(--bd); background:rgba(255,255,255,.06)}
  pre{white-space:pre-wrap; word-break:break-word; margin:0}
</style>
</head>
<body>
<div class="wrap">

  <div class="card">
    <h1>Web Watcher → Telegram</h1>
    <p class="muted small">Poll a web page for text every few seconds and send yourself a Telegram message when it appears. <strong>Don’t share this page with your token.</strong></p>
  </div>

  <div class="card">
    <h3>Watch settings</h3>
    <label>Page URL to watch</label>
    <input id="watchUrl" placeholder="https://example.com/page">
    <label>Text to look for (case-insensitive)</label>
    <input id="watchText" placeholder="e.g., in stock, tickets available, live now">
    <div class="row">
      <div style="flex:1; min-width:180px">
        <label>Poll interval (seconds)</label>
        <input id="intervalSec" type="number" min="1" step="1" value="3">
      </div>
      <div>
        <label>&nbsp;</label>
        <label class="row" style="gap:8px"><input id="sendOnce" type="checkbox" checked> Send once and stop</label>
      </div>
      <div>
        <label>&nbsp;</label>
        <label class="row" style="gap:8px"><input id="useProxy" type="checkbox"> Use CORS helper</label>
      </div>
    </div>
  </div>

  <div class="card">
    <h3>Telegram setup</h3>
    <p class="small muted">Create a bot with <strong>@BotFather</strong> → <code>/newbot</code>, copy the token, then press “Get Chat ID” after you’ve sent “/start” to your bot in Telegram.</p>
    <label>Bot token</label>
    <input id="botToken" placeholder="1234567890:ABCdefGHIjkLMNopQRstuVWxyz">
    <div class="row">
      <div style="flex:1; min-width:260px">
        <label>Your chat ID</label>
        <input id="chatId" placeholder="e.g., 123456789">
      </div>
      <div class="row" style="gap:8px">
        <button id="getChatId" class="ghost">Get Chat ID</button>
        <button id="testTelegram" class="ghost">Test Telegram</button>
      </div>
    </div>
  </div>

  <div class="card">
    <h3>Controls</h3>
    <div class="row">
      <button id="startBtn" class="ok">Start watching</button>
      <button id="stopBtn"  class="danger">Stop</button>
      <span id="status" class="pill right">idle</span>
    </div>
  </div>

  <div class="card">
    <h3>Log</h3>
    <pre id="log"></pre>
  </div>

  <div class="card">
    <h3>Notes</h3>
    <ul class="small muted">
      <li>This runs in your browser. Leaving the tab or device may pause it.</li>
      <li>Use the CORS helper if the target page blocks cross-origin fetches. It uses a read-only proxy (<code>https://r.jina.ai/http://…</code>) that returns page text.</li>
      <li>If you pasted your token publicly anywhere, <strong>regenerate it in @BotFather</strong> afterward.</li>
      <li>Please respect sites’ Terms of Service and avoid aggressive polling.</li>
    </ul>
  </div>

</div>

<script>
const $ = (s)=>document.querySelector(s);
const logEl = $('#log');
const statusEl = $('#status');
let timer = null;
let notifiedOnce = false;

function log(msg){
  const ts = new Date().toLocaleTimeString();
  logEl.textContent = `[${ts}] ${msg}\n` + logEl.textContent;
}

function saveSettings(){
  const data = {
    watchUrl: $('#watchUrl').value.trim(),
    watchText: $('#watchText').value,
    intervalSec: $('#intervalSec').value,
    sendOnce: $('#sendOnce').checked,
    useProxy: $('#useProxy').checked,
    botToken: $('#botToken').value.trim(),
    chatId: $('#chatId').value.trim()
  };
  localStorage.setItem('watcherSettings', JSON.stringify(data));
}

function loadSettings(){
  const s = localStorage.getItem('watcherSettings');
  if(!s) return;
  try{
    const d = JSON.parse(s);
    $('#watchUrl').value   = d.watchUrl || '';
    $('#watchText').value  = d.watchText || '';
    $('#intervalSec').value= d.intervalSec || 3;
    $('#sendOnce').checked = !!d.sendOnce;
    $('#useProxy').checked = !!d.useProxy;
    $('#botToken').value   = d.botToken || '';
    $('#chatId').value     = d.chatId || '';
  }catch{}
}
loadSettings();
document.querySelectorAll('input').forEach(i=>i.addEventListener('input', saveSettings));

function buildFetchUrl(url, useProxy){
  if(!useProxy) return url;
  // r.jina.ai proxy returns rendered text of the target URL (GET only, read-only)
  const u = new URL(url);
  return `https://r.jina.ai/http://${u.host}${u.pathname}${u.search}`;
}

async function fetchText(url, useProxy){
  try{
    const resp = await fetch(buildFetchUrl(url, useProxy), {
      headers: {'User-Agent':'WebWatcher/1.0'}
    });
    if(!resp.ok) throw new Error(`${resp.status} ${resp.statusText}`);
    return await resp.text();
  }catch(e){
    log('Fetch error: '+e.message);
    return '';
  }
}

async function sendTelegram(token, chatId, text){
  try{
    const resp = await fetch(`https://api.telegram.org/bot${encodeURIComponent(token)}/sendMessage`, {
      method:'POST',
      headers:{'Content-Type':'application/json'},
      body: JSON.stringify({ chat_id: chatId, text })
    });
    const data = await resp.json();
    if(!data.ok) throw new Error(JSON.stringify(data));
    log('Telegram sent ✓');
  }catch(e){
    log('Telegram error: '+e.message);
  }
}

async function getChatId(token){
  try{
    const resp = await fetch(`https://api.telegram.org/bot${encodeURIComponent(token)}/getUpdates`);
    const data = await resp.json();
    if(!data.ok) throw new Error(JSON.stringify(data));
    // Find the most recent message update that includes a chat id
    const upd = [...(data.result||[])].reverse().find(x => x.message && x.message.chat && x.message.chat.id);
    if(upd){
      $('#chatId').value = String(upd.message.chat.id);
      saveSettings();
      log('Chat ID detected: '+upd.message.chat.id);
    }else{
      log('No chat found. Open your bot in Telegram and send /start, then try again.');
    }
  }catch(e){
    log('getUpdates error: '+e.message);
  }
}

async function checkOnce(){
  const url = $('#watchUrl').value.trim();
  const needle = $('#watchText').value.toLowerCase();
  const useProxy = $('#useProxy').checked;

  if(!url || !needle){
    log('Please fill URL and text.');
    return false;
  }
  const html = await fetchText(url, useProxy);
  if(!html) return false;

  const found = html.toLowerCase().includes(needle);
  log(found ? 'Text FOUND' : 'Text not found');
  return found;
}

function start(){
  if(timer){ log('Already running.'); return; }
  const token = $('#botToken').value.trim();
  const chatId = $('#chatId').value.trim();
  const interval = Math.max(1, parseInt($('#intervalSec').value,10)||3) * 1000;
  const sendOnce = $('#sendOnce').checked;

  if(!token || !chatId){ log('Enter bot token and chat ID first.'); return; }

  notifiedOnce = false;
  statusEl.textContent = 'running…';
  timer = setInterval(async ()=>{
    const hit = await checkOnce();
    if(hit && (!sendOnce || !notifiedOnce)){
      notifiedOnce = true;
      const msg = `Alert: text "${$('#watchText').value}" found at ${$('#watchUrl').value}`;
      await sendTelegram(token, chatId, msg);
      if(sendOnce){
        stop();
        statusEl.textContent = 'done (sent once)';
      }
    }
  }, interval);
  log('Started. Polling every '+(interval/1000)+'s.');
}

function stop(){
  if(timer){
    clearInterval(timer);
    timer=null;
    statusEl.textContent = 'stopped';
    log('Stopped.');
  }
}

$('#startBtn').addEventListener('click', start);
$('#stopBtn').addEventListener('click', stop);
$('#testTelegram').addEventListener('click', async ()=>{
  const token = $('#botToken').value.trim();
  const chatId = $('#chatId').value.trim();
  if(!token || !chatId){ log('Enter token and chat ID first.'); return; }
  await sendTelegram(token, chatId, 'Test from Web Watcher ✅');
});
$('#getChatId').addEventListener('click', async ()=>{
  const token = $('#botToken').value.trim();
  if(!token){ log('Enter bot token first.'); return; }
  await getChatId(token);
});
</script>
</body>
</html>
