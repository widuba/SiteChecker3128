<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Web Watcher → Telegram</title>
<style>
  :root{
    --bg:#0f1221; --card:#161a31; --text:#eef1ff; --muted:#a4acc4;
    --accent:#7c5cff; --ok:#40d37a; --danger:#ff5470; --br:12px;
    --bd:1px solid rgba(255,255,255,.12)
  }
  *{box-sizing:border-box}
  body{
    margin:0; font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Arial;
    color:var(--text);
    background:
      radial-gradient(900px 500px at 12% -10%, rgba(124,92,255,.22), transparent),
      radial-gradient(700px 500px at 110% 0%, rgba(64,211,122,.18), transparent),
      var(--bg);
    min-height:100vh; display:grid; place-items:start center; padding:24px;
  }
  .wrap{width:100%; max-width:980px; display:grid; gap:16px}
  .card{background:linear-gradient(180deg,rgba(255,255,255,.05),rgba(255,255,255,.02));
        border:var(--bd); border-radius:var(--br); padding:16px}
  h1,h2,h3{margin:0 0 10px}
  .muted{color:var(--muted)} .small{font-size:.92rem}
  label{display:block; font-weight:600; margin:10px 0 6px}
  input,button,textarea,select{font:inherit; color:var(--text)}
  input,textarea,select{
    width:100%; background:#121530; border:var(--bd); border-radius:10px; padding:10px 12px; outline:none;
  }
  textarea{min-height:100px; resize:vertical}
  .row{display:flex; gap:10px; align-items:center; flex-wrap:wrap}
  .right{margin-left:auto}
  button{background:var(--accent); border:0; padding:10px 14px; border-radius:10px; cursor:pointer}
  .ghost{background:transparent; border:var(--bd)}
  .ok{background:var(--ok); color:#04160d}
  .danger{background:var(--danger)}
  .pill{padding:6px 10px; border-radius:999px; border:var(--bd); background:rgba(255,255,255,.06)}
  pre{white-space:pre-wrap; word-break:break-word; margin:0}
  .grid2{display:grid; gap:12px; grid-template-columns:1fr 1fr}
  @media (max-width:880px){ .grid2{grid-template-columns:1fr} }
  code{background:rgba(255,255,255,.08); padding:2px 6px; border-radius:6px}
</style>
</head>
<body>
<div class="wrap">

  <div class="card">
    <h1>Web Watcher → Telegram</h1>
    <p class="muted small">Poll a web page and send yourself a Telegram message when your target appears. Use advanced match modes if the page renders dynamically. <strong>Don’t share this page with your token.</strong></p>
  </div>

  <div class="card">
    <h3>Watch settings</h3>
    <label>Page URL to watch</label>
    <input id="watchUrl" placeholder="https://example.com/page">

    <div class="grid2">
      <div>
        <label>Match mode</label>
        <select id="matchMode">
          <option value="plain" selected>Plain contains (case-insensitive)</option>
          <option value="regex">Regex (advanced)</option>
          <option value="selector">CSS selector (search text in elements)</option>
        </select>
      </div>
      <div id="plainRow">
        <label>Text to look for</label>
        <input id="watchText" placeholder='e.g., "in stock", "live now"'>
      </div>
      <div id="regexRow" style="display:none">
        <label>Regex pattern (no slashes)</label>
        <input id="regexPattern" placeholder="e.g., (in\\s*stock|available)\\b">
        <label>Flags</label>
        <input id="regexFlags" value="i" placeholder="i, g, m, s, u, y">
      </div>
      <div id="selectorRow" style="display:none">
        <label>CSS selector</label>
        <input id="cssSelector" placeholder=".status, #availability, td:nth-child(2)">
        <label>Optional: text filter (contains)</label>
        <input id="selectorFilter" placeholder="e.g., In Stock">
      </div>
    </div>

    <div class="row">
      <div style="flex:1; min-width:180px">
        <label>Poll interval (seconds)</label>
        <input id="intervalSec" type="number" min="1" step="1" value="3">
      </div>
      <div>
        <label>&nbsp;</label>
        <label class="row" style="gap:8px"><input id="sendOnce" type="checkbox" checked> Send once and stop</label>
      </div>
      <div>
        <label>&nbsp;</label>
        <label class="row" style="gap:8px"><input id="useProxy" type="checkbox"> Use CORS helper</label>
      </div>
      <div>
        <label>&nbsp;</label>
        <label class="row" style="gap:8px"><input id="normalizeWS" type="checkbox" checked> Normalize whitespace</label>
      </div>
      <div>
        <label>&nbsp;</label>
        <label class="row" style="gap:8px"><input id="useDomText" type="checkbox" checked> Use DOM text extraction</label>
      </div>
    </div>
  </div>

  <div class="card">
    <h3>Telegram setup</h3>
    <p class="small muted">Create a bot with <strong>@BotFather</strong> → <code>/newbot</code>, copy the token, then press “Get Chat ID” after you’ve sent <code>/start</code> to your bot.</p>
    <label>Bot token</label>
    <input id="botToken" placeholder="1234567890:ABCdefGHIjkLMNopQRstuVWxyz">
    <div class="row">
      <div style="flex:1; min-width:260px">
        <label>Your chat ID</label>
        <input id="chatId" placeholder="e.g., 123456789">
      </div>
      <div class="row" style="gap:8px">
        <button id="getChatId" class="ghost">Get Chat ID</button>
        <button id="testTelegram" class="ghost">Test Telegram</button>
      </div>
    </div>
  </div>

  <div class="card">
    <h3>Controls</h3>
    <div class="row">
      <button id="startBtn" class="ok">Start watching</button>
      <button id="stopBtn"  class="danger">Stop</button>
      <span id="status" class="pill right">idle</span>
    </div>
  </div>

  <div class="card">
    <h3>Log</h3>
    <pre id="log"></pre>
  </div>

  <div class="card">
    <h3>Notes</h3>
    <ul class="small muted">
      <li>If the page renders content via JavaScript, use <strong>Use DOM text extraction</strong> + <strong>CORS helper</strong>, or target specific elements with <strong>CSS selector</strong>.</li>
      <li>The proxy (<code>https://r.jina.ai/https://…</code>) returns readable page text; heavy SPA pages may still need a server-side worker for full rendering.</li>
      <li>Respect sites’ Terms; increase interval to avoid rate limits (e.g., 10–15s).</li>
    </ul>
  </div>

</div>

<script>
const $ = (s)=>document.querySelector(s);
const logEl = $('#log');
const statusEl = $('#status');
let timer = null;
let notifiedOnce = false;

// UI sections switching
const modeSel = $('#matchMode');
const plainRow = $('#plainRow');
const regexRow = $('#regexRow');
const selectorRow = $('#selectorRow');
modeSel.addEventListener('change', ()=>{
  plainRow.style.display    = modeSel.value === 'plain'    ? '' : 'none';
  regexRow.style.display    = modeSel.value === 'regex'    ? '' : 'none';
  selectorRow.style.display = modeSel.value === 'selector' ? '' : 'none';
  saveSettings();
});

function log(msg){
  const ts = new Date().toLocaleTimeString();
  logEl.textContent = `[${ts}] ${msg}\n` + logEl.textContent;
}

function saveSettings(){
  const data = {
    watchUrl: $('#watchUrl').value.trim(),
    matchMode: $('#matchMode').value,
    watchText: $('#watchText').value,
    regexPattern: $('#regexPattern')?.value || '',
    regexFlags: $('#regexFlags')?.value || 'i',
    cssSelector: $('#cssSelector')?.value || '',
    selectorFilter: $('#selectorFilter')?.value || '',
    intervalSec: $('#intervalSec').value,
    sendOnce: $('#sendOnce').checked,
    useProxy: $('#useProxy').checked,
    normalizeWS: $('#normalizeWS').checked,
    useDomText: $('#useDomText').checked,
    botToken: $('#botToken').value.trim(),
    chatId: $('#chatId').value.trim()
  };
  localStorage.setItem('watcherSettingsV2', JSON.stringify(data));
}

function loadSettings(){
  const s = localStorage.getItem('watcherSettingsV2');
  if(!s) return;
  try{
    const d = JSON.parse(s);
    $('#watchUrl').value    = d.watchUrl || '';
    $('#matchMode').value   = d.matchMode || 'plain';
    $('#watchText').value   = d.watchText || '';
    $('#regexPattern').value= d.regexPattern || '';
    $('#regexFlags').value  = d.regexFlags || 'i';
    $('#cssSelector').value = d.cssSelector || '';
    $('#selectorFilter').value = d.selectorFilter || '';
    $('#intervalSec').value = d.intervalSec || 3;
    $('#sendOnce').checked  = !!d.sendOnce;
    $('#useProxy').checked  = !!d.useProxy;
    $('#normalizeWS').checked = !!d.normalizeWS;
    $('#useDomText').checked = d.useDomText !== false; // default true
    $('#botToken').value    = d.botToken || '';
    $('#chatId').value      = d.chatId || '';
    // update rows
    modeSel.dispatchEvent(new Event('change'));
  }catch{}
}
loadSettings();
document.querySelectorAll('input,select').forEach(i=>i.addEventListener('input', saveSettings));

function buildFetchUrl(url, useProxy){
  if(!useProxy) return url;
  const u = new URL(url);
  return `https://r.jina.ai/${u.protocol}//${u.host}${u.pathname}${u.search}`;
}

async function fetchText(url, useProxy){
  const controller = new AbortController();
  const t = setTimeout(()=>controller.abort(), 15000); // 15s timeout
  try{
    const resp = await fetch(buildFetchUrl(url, useProxy), {
      headers: { 'User-Agent':'Mozilla/5.0 (compatible; WebWatcher/1.0)' },
      signal: controller.signal,
      cache: 'no-store'
    });
    clearTimeout(t);
    if(!resp.ok){
      throw new Error(`${resp.status} ${resp.statusText}`);
    }
    return await resp.text();
  }catch(e){
    clearTimeout(t);
    if(!useProxy){
      log('Fetch error (try enabling "Use CORS helper"): ' + e.message);
    }else{
      log('Fetch error via proxy: ' + e.message);
    }
    return '';
  }
}

function toDomText(html){
  try{
    const doc = new DOMParser().parseFromString(html, 'text/html');
    // remove scripts/styles/noscript
    doc.querySelectorAll('script,style,noscript').forEach(n=>n.remove());
    const text = doc.body ? doc.body.innerText || doc.body.textContent || '' : '';
    return text;
  }catch{
    return html;
  }
}

function normalizeWS(s){
  return s.replace(/\s+/g,' ').trim();
}

function slicePreview(s, start, len=180){
  const a = Math.max(0, start - Math.floor(len/2));
  const b = Math.min(s.length, a + len);
  return s.slice(a, b);
}

function findInPlainText(fullText, needle, doNormalize){
  const hay = doNormalize ? normalizeWS(fullText) : fullText;
  const nee = doNormalize ? normalizeWS(needle) : needle;
  const hayLC = hay.toLowerCase();
  const neeLC = nee.toLowerCase();
  const idx = hayLC.indexOf(neeLC);
  return idx >= 0 ? { found:true, idx, preview: slicePreview(hay, idx) } : { found:false };
}

function findWithRegex(fullText, pattern, flags, doNormalize){
  const hay = doNormalize ? normalizeWS(fullText) : fullText;
  try{
    const re = new RegExp(pattern, flags || 'i');
    const m = hay.match(re);
    if(m){
      const idx = m.index || hay.indexOf(m[0]);
      return { found:true, idx, preview: slicePreview(hay, idx) };
    }
  }catch(e){
    log('Regex error: ' + e.message);
  }
  return { found:false };
}

function findWithSelector(fullHtml, selector, filterText, doNormalize){
  try{
    const doc = new DOMParser().parseFromString(fullHtml, 'text/html');
    const els = selector ? [...doc.querySelectorAll(selector)] : [];
    if(els.length === 0) return { found:false };
    const texts = els.map(el => el.innerText || el.textContent || '').join('\n');
    if(!filterText) {
      // if no filter given, just report found (since elements exist)
      return { found:true, idx:0, preview: slicePreview(texts, 0) };
    }
    const hay = doNormalize ? normalizeWS(texts) : texts;
    const nee = doNormalize ? normalizeWS(filterText) : filterText;
    const hayLC = hay.toLowerCase();
    const neeLC = nee.toLowerCase();
    const idx = hayLC.indexOf(neeLC);
    return idx >= 0 ? { found:true, idx, preview: slicePreview(hay, idx) } : { found:false };
  }catch(e){
    log('Selector parse error: ' + e.message);
    return { found:false };
  }
}

async function sendTelegram(token, chatId, text){
  try{
    const resp = await fetch(`https://api.telegram.org/bot${encodeURIComponent(token)}/sendMessage`, {
      method:'POST',
      headers:{'Content-Type':'application/json'},
      body: JSON.stringify({ chat_id: chatId, text })
    });
    const data = await resp.json();
    if(!data.ok) throw new Error(JSON.stringify(data));
    log('Telegram sent ✓');
  }catch(e){
    log('Telegram error: '+e.message);
  }
}

async function getChatId(token){
  try{
    const resp = await fetch(`https://api.telegram.org/bot${encodeURIComponent(token)}/getUpdates`);
    const data = await resp.json();
    if(!data.ok) throw new Error(JSON.stringify(data));
    const upd = [...(data.result||[])].reverse().find(x => x.message && x.message.chat && x.message.chat.id);
    if(upd){
      $('#chatId').value = String(upd.message.chat.id);
      saveSettings();
      log('Chat ID detected: '+upd.message.chat.id);
    }else{
      log('No chat found. Open your bot and send /start, then try again.');
    }
  }catch(e){
    log('getUpdates error: '+e.message);
  }
}

async function checkOnce(){
  const url = $('#watchUrl').value.trim();
  const mode = $('#matchMode').value;
  const doNormalize = $('#normalizeWS').checked;
  const useProxy = $('#useProxy').checked;
  const useDom = $('#useDomText').checked;

  if(!url){
    log('Please enter a URL.');
    return {found:false};
  }

  const html = await fetchText(url, useProxy);
  if(!html) return {found:false};

  const base = useDom ? toDomText(html) : html;

  if(mode === 'plain'){
    const needle = $('#watchText').value;
    if(!needle){ log('Enter text to look for.'); return {found:false}; }
    const res = findInPlainText(base, needle, doNormalize);
    if(res.found) log('FOUND (plain) — preview: ' + res.preview);
    else log('Not found (plain).');
    return res;
  }

  if(mode === 'regex'){
    const pat = $('#regexPattern').value;
    const flags = $('#regexFlags').value || 'i';
    if(!pat){ log('Enter a regex pattern.'); return {found:false}; }
    const res = findWithRegex(base, pat, flags, doNormalize);
    if(res.found) log('FOUND (regex) — preview: ' + res.preview);
    else log('Not found (regex).');
    return res;
  }

  if(mode === 'selector'){
    const sel = $('#cssSelector').value;
    const filter = $('#selectorFilter').value;
    if(!sel){ log('Enter a CSS selector.'); return {found:false}; }
    const res = findWithSelector(html, sel, filter, doNormalize);
    if(res.found) log('FOUND (selector) — preview: ' + (res.preview || '[element present]'));
    else log('Not found (selector).');
    return res;
  }

  return {found:false};
}

function start(){
  if(timer){ log('Already running.'); return; }
  const token = $('#botToken').value.trim();
  const chatId = $('#chatId').value.trim();
  const interval = Math.max(1, parseInt($('#intervalSec').value,10)||3) * 1000;
  const sendOnce = $('#sendOnce').checked;

  if(!token || !chatId){ log('Enter bot token and chat ID first.'); return; }

  notifiedOnce = false;
  statusEl.textContent = 'running…';
  timer = setInterval(async ()=>{
    const {found} = await checkOnce();
    if(found && (!sendOnce || !notifiedOnce)){
      notifiedOnce = true;
      const mode = $('#matchMode').value;
      const desc =
        mode === 'plain' ? `text "${$('#watchText').value}"`
      : mode === 'regex' ? `regex /${$('#regexPattern').value}/${$('#regexFlags').value||'i'}`
      : `selector "${$('#cssSelector').value}"${ $('#selectorFilter').value ? ` contains "${$('#selectorFilter').value}"` : '' }`;

      const msg = `Alert: ${desc} found at ${$('#watchUrl').value}`;
      await sendTelegram(token, chatId, msg);
      if(sendOnce){
        stop();
        statusEl.textContent = 'done (sent once)';
      }
    }
  }, interval);
  log('Started. Polling every '+(interval/1000)+'s.');
}

function stop(){
  if(timer){
    clearInterval(timer);
    timer=null;
    statusEl.textContent = 'stopped';
    log('Stopped.');
  }
}

$('#startBtn').addEventListener('click', start);
$('#stopBtn').addEventListener('click', stop);
$('#testTelegram').addEventListener('click', async ()=>{
  const token = $('#botToken').value.trim();
  const chatId = $('#chatId').value.trim();
  if(!token || !chatId){ log('Enter token and chat ID first.'); return; }
  await sendTelegram(token, chatId, 'Test from Web Watcher ✅');
});
$('#getChatId').addEventListener('click', async ()=>{
  const token = $('#botToken').value.trim();
  if(!token){ log('Enter bot token first.'); return; }
  await getChatId(token);
});

// Persist immediately on first load so your defaults are saved
saveSettings();
</script>
</body>
</html>
